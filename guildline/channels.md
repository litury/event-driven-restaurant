# Обзор возможностей @mcdis/design
## Очереди

### Channel
Доступны с версии 2.4

**Channel** — это универсальный инструмент для организации асинхронных очередей сообщений между различными частями приложения или потоками выполнения. Channel реализует потокобезопасный обмен сообщениями, поддерживает ограниченную и неограниченную ёмкость, а также различные политики обработки переполнения.

**Для чего это нужно:**
Channel особенно полезен там, где надо:

* Буферизовать сообщения между продюсерами и консюмерами (например, producer/consumer pattern)
* Разделять нагрузку между воркерами
* Имплементировать асинхронные пайплайны/конвейеры
* Организовывать поток событий между изолированными частями системы
* Управлять backpressure и обработкой переполнения очереди

#### Ключевые особенности:

* Асинхронные операции записи и чтения (`writeAsync`, `readAsync`)
* Разные политики переполнения: ожидание, вытеснение старых, дроп новых, игнор записи
* Возможность получать уведомления о событиях (хуки)
* Безопасность для конкурентного использования

---

### Примеры создания очереди

#### Ограниченная очередь (Bounded Channel)

```ts
import { createBoundedChannel, ChannelFullMode } from '@mcdis/design';

// Создаёт очередь максимум на 3 элемента. При переполнении — вытесняет старые.
const queue = createBoundedChannel<number>(3, ChannelFullMode.DropOldest);

await queue.writeAsync(1);
await queue.writeAsync(2);
await queue.writeAsync(3);
await queue.writeAsync(4); // 1 будет вытеснен, в очереди останутся 2, 3, 4

console.log(queue.tryRead()); // 2
```

#### Безразмерная очередь (Unbounded Channel)

```ts
import { createUnboundedChannel } from '@mcdis/design';

// Создаёт очередь без ограничения по размеру
const queue = createUnboundedChannel<string>();

await queue.writeAsync("a");
await queue.writeAsync("b");
console.log(queue.tryRead()); // "a"
```

#### Канал с хуками (логирование событий)

```ts
import { createBoundedChannel, ChannelFullMode } from '@mcdis/design';

const queue = createBoundedChannel<number>(
  2,
  ChannelFullMode.DropNewest,
  {
    onWrite: (item) => console.log("В очередь добавлено:", item),
    onRead: (item) => console.log("Из очереди извлечено:", item),
    onDrop: (item, reason) => console.warn(`Элемент ${item} был отброшен по причине: ${reason}`)
  }
);

await queue.writeAsync(10); // В очередь добавлено: 10
await queue.writeAsync(20); // В очередь добавлено: 20
queue.tryWrite(30);         // onDrop: элемент 30 был отброшен (DropNewest)
console.log(queue.tryRead()); // Из очереди извлечено: 10
```

#### Асинхронная обработка очереди (пайплайн)

```ts
import { createBoundedChannel } from '@mcdis/design';

const input = createBoundedChannel<number>(10);

// Воркеры асинхронно обрабатывают очередь
(async () => {
  while (true) {
    const value = await input.readAsync();
    console.log("Обработано:", value);
  }
})();

// Генерируем сообщения
for (let i = 0; i < 5; i++) {
  await input.writeAsync(i);
}
```

Вот пример отдельного подраздела для документации:

---

### Режимы переполнения (Full Modes)

Когда очередь (Channel) достигает предельной ёмкости, её поведение определяется режимом переполнения (`ChannelFullMode`). Это позволяет гибко управлять реакцией на попытки записать элемент в заполненный канал — в зависимости от особенностей вашего сценария.

#### Доступные режимы

* **Wait**
  Ожидать освобождения места.
  Запись при заполненном буфере блокируется (асинхронно ожидает), пока кто-то не извлечёт элемент из очереди.
  *Используется по умолчанию для большинства задач, где нельзя терять данные.*

  ```ts
  const ch = createBoundedChannel(2, ChannelFullMode.Wait);
  // Пока не освободится место — writeAsync будет ждать
  ```

* **DropNewest**
  Отбросить новое сообщение.
  Если очередь заполнена, новая запись игнорируется (элемент не попадает в канал).
  Хук `onDrop` будет вызван для отброшенного элемента.

  ```ts
  const ch = createBoundedChannel(2, ChannelFullMode.DropNewest);
  await ch.writeAsync(1);
  await ch.writeAsync(2);
  ch.tryWrite(3); // 3 будет отброшен
  ```

* **DropOldest**
  Вытеснить самый старый элемент.
  При переполнении канал удаляет первый (старый) элемент и кладёт новый.
  Удобно для сценариев, где важнее "свежие" данные.

  ```ts
  const ch = createBoundedChannel(2, ChannelFullMode.DropOldest);
  await ch.writeAsync(1);
  await ch.writeAsync(2);
  await ch.writeAsync(3); // 1 будет вытеснен, останутся 2, 3
  ```

* **DropWrite**
  Игнорировать запись при переполнении.
  Новая запись просто не выполняется, никакой элемент не удаляется из очереди.
  Семантически отличается от DropNewest только сигналами — используется, когда важен факт попытки записи.

  ```ts
  const ch = createBoundedChannel(2, ChannelFullMode.DropWrite);
  await ch.writeAsync(1);
  await ch.writeAsync(2);
  ch.tryWrite(3); // 3 будет отброшен, очередь не изменится
  ```

---

#### Когда какой режим выбирать?

* `Wait` — для надёжных очередей, где нужно **гарантировать доставку** всех сообщений (например, обработка заказов, событий).
* `DropNewest` — для сценариев, где **важнее не блокироваться**, а потеря части событий некритична (например, телеметрия).
* `DropOldest` — для потоков данных, где **важнее свежесть**, а не история (например, сэмплирование состояния).
* `DropWrite` — для легковесных уведомлений, когда можно игнорировать лишние попытки записи.

> Любой режим можно комбинировать с хуком `onDrop`, чтобы логировать или отслеживать отброшенные элементы.

---

**Пример: логируем отброшенные сообщения**

```ts
const queue = createBoundedChannel<number>(
  2,
  ChannelFullMode.DropNewest,
  {
    onDrop: (item, reason) => console.warn(`Сообщение ${item} отброшено: ${reason}`)
  }
);

await queue.writeAsync(100);
await queue.writeAsync(200);
queue.tryWrite(300); // Сообщение 300 отброшено: dropNewest
```

Вот раздел для документации, поясняющий, как работает закрытие канала (`close()`):

---

### Завершение и закрытие канала (`close()`)

Метод **`close()`** переводит канал в состояние "закрыт":

* **Запись новых элементов больше невозможна** (все последующие попытки записи вызовут ошибку или будут отвергнуты согласно политике режима).
* **Чтение ещё возможно** — пока в очереди остаются элементы, их можно забирать через `readAsync` или `tryRead`.
* После того как все элементы из очереди считаны, канал считается полностью завершённым (promise `completion` резолвится).

Это полезно для корректного завершения работы потоков или оповещения подписчиков о том, что больше данных не поступит.

#### Когда вызывать `close()`?

* Когда ваш поток/источник данных завершён и новых сообщений больше не будет.
* Чтобы "дружелюбно" завершить все ожидающие и новые операции записи/чтения.

#### Поведение после вызова `close()`:

* **Все ожидающие записи** (`writeAsync`, `waitToWriteAsync`) завершатся ошибкой или вернут `false`.
* **Ожидающие чтения** (`readAsync`, `waitToReadAsync`) завершатся успешно, пока очередь не пуста. После этого они завершаются с ошибкой/`false`.
* **Метод `completion`** (promise) резолвится после того, как очередь опустеет (все элементы считаны).

---

#### Пример использования

```ts
const ch = createBoundedChannel<number>(2);

// Заполняем очередь
await ch.writeAsync(1);
await ch.writeAsync(2);

// Закрываем канал для новых записей
ch.close();

// Читаем оставшиеся элементы
console.log(await ch.readAsync()); // 1
console.log(await ch.readAsync()); // 2

// Попытка читать дальше — завершится ошибкой или undefined
// (зависит от реализации и способа вызова)
try {
  await ch.readAsync(); // Ошибка: Channel closed
} catch (err) {
  console.error(err);
}

// Проверка завершения
await ch.completion; // Promise выполнится, когда очередь пуста
```

---

#### Важные моменты

* **`close()` не удаляет элементы** — только запрещает новые записи.
* После `close()` канал можно только читать, пока не опустеет.
* Канал может быть закрыт только один раз; повторные вызовы игнорируются.

---

**Итого:**
`close()` — это способ корректно завершить канал и дать всем читателям шанс обработать накопленные данные, без риска потерять сообщения. Это важно для graceful shutdown паттернов и "мягкого" завершения асинхронных очередей.

---

Вот расширенный раздел с пояснением работы метода `tryComplete`:

---

### Завершение канала: `close()` и `tryComplete()`

#### Кратко

* **`close()`** — мягко закрывает канал для записи, но позволяет дочитать всё из очереди. Не сигнализирует об ошибке.
* **`tryComplete(error?)`** — полностью завершает канал, опционально с ошибкой. После этого любые операции записи и чтения становятся невозможны (кроме чтения оставшихся данных в очереди).

---

#### Что делает `tryComplete`?

Метод `tryComplete(error?)` переводит канал в финальное состояние:

* Если канал ещё открыт, он сразу становится завершённым (`Completed`) или завершённым с ошибкой (`Errored`), если передан аргумент `error`.
* Все ожидающие записи и чтения немедленно получают ошибку (или `false`, если они были в режиме ожидания).
* Очередь остаётся доступна для чтения до полного опустошения (если не было ошибки).

**В отличие от `close()`, который только запрещает новые записи, `tryComplete()` фиксирует окончательное состояние канала**.

---

#### Когда использовать `tryComplete`?

* Если обработка завершилась с ошибкой, которую важно донести до всех читателей/писателей.
* Если вы хотите явным образом “отрубить” канал (например, при аварийном завершении или отмене задачи).
* Когда нужен контроль над жизненным циклом: канал закрывается и сигнализирует всем подписчикам о причине завершения.

---

#### Пример

```ts
const channel = createBoundedChannel<number>(5);

async function producer() {
  try {
    for (let i = 0; i < 10; i++) {
      await channel.writeAsync(i);
    }
    // Успешное завершение — закрываем канал для записи
    channel.close();
  } catch (err) {
    // Аварийное завершение с ошибкой
    channel.tryComplete(err);
  }
}

async function consumer() {
  try {
    while (true) {
      const value = await channel.readAsync();
      console.log(value);
    }
  } catch {
    // Канал завершён или произошла ошибка
  }
  await channel.completion;
  console.log("Канал окончательно завершён");
}
```

---

#### Особенности

* `tryComplete` возвращает `true`, если завершение было выполнено, и `false`, если канал уже был завершён.
* Если передан параметр `error`, канал считается завершённым с ошибкой: все новые и ожидающие операции записи/чтения завершатся с исключением.
* После вызова `tryComplete` дальнейшие записи/ожидания будут приводить к исключению или ошибке.

---

#### Различия между `close()` и `tryComplete()`

|                  | close()                | tryComplete()              |
| ---------------- | ---------------------- | -------------------------- |
| Запись           | Запрещена              | Запрещена                  |
| Чтение           | До опустошения очереди | До опустошения очереди     |
| Ожидающие записи | Резолвятся `false`     | Резолвятся ошибкой/`false` |
| Ожидающие чтения | Резолвятся `false`     | Резолвятся ошибкой/`false` |
| Передаёт ошибку  | Нет                    | Да (если передать error)   |
| Сигнал всем      | Только о закрытии      | О завершении/ошибке        |
| Используется для | Нормальное завершение  | Явное/аварийное завершение |