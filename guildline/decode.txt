00:00
деле давайте о чем вообще почему посвящено в общем на собрании и следующие собрания они посвящены такой вещь которая называется

00:13
тремя буквами С и П.  Это значит комплекс. Комплекс. есть сложные. Сложное.  E это event.  Событие. или события. И P это processing. Процессинг. Обработка. То есть...

00:41
системы сложной обработки событий. Вот иногда по инерции их называют,  относят к классу ETL системам, хотя это не совсем так.  Вот значит,  чтобы добраться до вот сложных систем обработки, рассмотрим еще две системы, которые на практике применяют.

01:10
Это вот E-T-L и еще E-L-T. При этом, на самом деле, E-T-L считается более устаревшей подходом по сравнению с E-L-T.  Но сложная обработка событий — это еще более современный подход. Что такое E-L-T?  И как это расшифровывается? Это волшебная аббревиатура.

01:40
Она расшифровывается как экстракт, то есть извлечь,  загрузить, преобразовать.  Transform.  E-L-T. А E-T-L тоже самое, только другой порядок. То есть экстракт, transform.

02:04
Лот

02:07
чем они изначально отличались и почему ел т считается считается более свежей концепции ну экстракт это соответственно получение данных с какого-то источника да то есть источником бывают там базы данных бывают какие-то системы измерения там

02:28
которые выдают нам какие-то показатели,  камеры, всё что угодно. Всё, что может выдавать параметры,  данные.  Получение этих данных с источника называется фаза экстракта.

02:47
Обычно данные, которые мы получаем с источников, их часто называют сырыми. Использую такое слово «ро» по-английски. Это сырые данные, то есть как бы необработанные. есть мне, например,  люди крикают как сумасшедшие на кнопочку «лайк». Я получаю, значит, эти вот сведения, что там первый лайкнул, второй лайкнул, еще что-то там произошло или там 20 человек лайкнуло. Это сырые данные.

03:15
не обработан кто-то два раза лайкнул кто-то там пять раз лайкнул кто-то вначале лайкнул а потом нажал дизлайк то есть это сырые данные дальше соответственно как бы старый подход заключается в том что данные сразу же на месте как вот мы их получили они преобразовывались

03:37
Ну, например, мы сразу делали какой-то подсчет, что-то с этим делали.  И третья часть, да,  это load. Это загрузка. Загрузка данных уже в базу данных, на самом деле. То есть вот в подходах ELT и ETL загрузка предлагает обычно какую-то базу данных. То есть это может быть файловое хранилище,  там база данных,  там SQL база данных или NoSQL база данных или там какая-нибудь там...

04:07
для аналитических данных, то есть это фаза загрузки.  Вот. То есть тут получается в случае E2L мы получили данные, сразу их по месту обработали, например, посчитали какое-то среднее или минимальное за какой-то период времени и загрузили в базу. То есть в базе уже как бы данные хранятся обработанные.  Назовем это процесс или их еще иногда называют очищенные данные. Напишем процесс.

04:37
процесс или там Clint не знаю, может неправильно по-английски, может так не говорят, но я так напишу. Значит, есть данные обработаны.  И, соответственно, почему вот этот подход E-Tel устарел? Очень просто, потому что на момент, когда мы производим разработку программирования нашей системы, мы до конца не уверены, что через пять дней или через месяц или через полгода

05:07
нам не понадобится какая-то другая обработка. есть получается,  что при E.T.L. происходит потеря некоторых характеристик,  которыми могут обладать сырые данные. То есть может быть в сырых данных есть какая-то хитрая закономерность, которую можно эксплуатировать для извлечения прибыли или для получения какой-то полезности. Так вот, случае нашей обработки, ну, например,  там усреднение или там суммирование за минуту.

05:37
мы теряем часть информации. есть у нас были клики по времени,  а получился просто объем кликов за минуту. То потеря данных, потеря свойств происходит. Поэтому народ перешел на принцип ELT. То есть ELT заключается следующим образом.  типа, ребят, мы давайте, мы же мощные ребята, нас мощное железо, мы хорошо справляемся с толстыми каналы.

06:05
Давайте мы сырые данные сразу загрузим в базу данных.

06:11
или в какую-то систему управления база данных.  А уже преобразование,  трансформацию, изменение этих данных мы будем делать внутри базы. То трансформ тут происходит.

06:31
То есть мы получили сырые данные,  соответственно,  загружаем, в каком виде есть базу данных,  и потом уже преобразовываем. Отличие какое?  Поскольку мы сохранили данные в исходном виде, мы можем потом в будущем как-то извлечь из этого выгоду. То есть мы такие,  оказывается, нас появились e-mail модели, а где у нас данные?

06:58
систем машинного обучения нужны большие объемы. Желательно там от 100 тысяч единиц, а еще лучше, тебя миллионы или даже сотни миллионов данных. А если ты их осреднял до уровня раз в неделю, примеру, то у тебя оказывается всего тысячи этих данных за два года работы, и оказывается тысяча это ни о чем.  И соответственно, если и были закономенности, ты их потерял. Поэтому, соответственно, народ ушел в сторону ELT.

07:26
А вот такие базы данных, точнее даже не базы данных, системы управления баз данными, где надо хранить дофигище всяких параметров,  стали называть озероданными. Ну или как-то такое слово,  там, красиво они придумали.  озероданных.

07:44
озера потому что все туда надо затолкать для того чтобы потом уже обрабатывать то есть первую очередь надо сохранить а потом уже будем думать как оттуда это извлекать вот ну и на смену этой системы пришли новые системы но опять же до озера данных они как бы не резиновые вот что во первых поток данного потоков данных много

08:09
Ну то есть,  необходимо много данных собирать. Но есть еще одна проблема,  такая качественная,  это лаг. То есть, народ такой классный, мы работаем с камазами данных. Это прям прекрасно. Но мы-то хотим теперь быстро работать с этими объемами данных. И народ говорит, я хочу все то же самое, только быстрее.  Его интересует лаг.

08:36
Лаг — это время,  которое проходит с момента поступления данных с этого места до того момента, когда они будут обработаны и отданы пользователю. То есть тут у нас человечек есть, который радостно это дело получил. И соответственно данные и время,  которое...

08:55
соответственно, эта вот информация все проходит от источника до потребителя, это лаг. Ну и народ захотел системы с низкой задержкой.  Это называется low latency. Low latency system. То есть они захотели не просто с большими данными работать, а уметь быстро их обрабатывать, отдавать пользователю. Вот.

09:25
Но в целом везде выполняется закон сохранения и нельзя получить качественный прирост не пожертвовав чем-то. Если мы хотим низкую задержку, мы должны чем-то пожертвовать.  И первое чем пожертвовали это требованиям на консистентость.

09:51
консист консист то есть что такое требование на консистент в базах данных хранится информация она должна быть согласована и этот отнимает куча ресурсов в том числе самое важное время вот то есть грубо говоря требования на консистенция заключается в следующем что в любой момент времени

10:13
Данные, которые лежат в базе данных, должны быть согласованы.  Это имеет отношение к системам управления баз данным,  на основе SQL, на основе ограничений,  которые контролируют, что данные непротиворечивы, что у нас есть таблица пользователей и таблица удостоверения водительских,  и что в таблице удостоверения водительских не указан пользователь, которого нет.

10:43
значит этим пожертвовали и перешли качественно на новый уровень, который называется Time Consistency.

10:53
То есть тайм консистенции.

10:59
Что такое time consistency?  Это такая система,  данный по которой приходит согласованное состояние со временем при условии того,  что отсутствует изменение. есть, грубо говоря, нас что-то там происходит,  мы воду палкой побили,  камни покидали, пошли нас по волне круги вот эти вот.

11:29
Волны пошли,  волны начали от всяких бортиков отражаться,  нас вода в виде наших данных, она испытывает возмущение, но если ее перестать трогать, она перейдет в плоскую поверхность, то есть она устаканится и все будет четко согласовано.  Тут то же самое, у нас есть потоки данных, давайте простой пример, это какие-нибудь там

11:59
клики, лайки,  люди как сумасшедшие, потребляя короткие видосы, щелкают. У нас есть куча-куча этих лайков, и мы должны людям показывать счетчик, самый простой счетчик, сколько этих лайков натыкали. Так вот, тайм консистенции говорит о том,  что нам не важно, что он краткосрочно может не врать нам. Нам важно, что рано или поздно люди перестанут лайкать.

12:27
И в условиях того, что они какое-то время не будут лайкать или вообще не будут лайкать,  этот счетчик в итоге придет к правильному показателю. Тому, какой он является на самом деле.  И это требование позволяет как раз получить и начать создавать вот такие вот соответственно

12:57
системы с низкой задержкой,  которые основаны на обработке данных. Сейчас мы двигаемся дальше и переходим к комплексам processing. Что это такое?  С чем ее едят?  двигаемся дальше.  Комплекс processing говорит о следующем.

13:26
что, во-первых,  аббревиатуре есть слово событие.

13:31
event.  Что такое событие? Событие это порция информации.

13:43
произошла какое-то время.

13:47
там пусть там t 0 будет вот и датом е 1 t 1 и это порция информации самое что важно она никогда не меняется со временем то есть ее качественная у нее две качественные характеристики но во первых она произошла в какой-то момент времени ты один это первое что надо знать событий то есть оно всегда когда-то происходит

14:15
Вот вторая на самом деле вещь, что событие хранит порцию информации, и оно неизменяемое. Immutable – это ее качественная характеристика. То есть событие никогда не может изменить. То, что уже случилось, то случилось. Соответственно, если мы теперь рассмотрим набор событий, там E2, T2,

14:44
то оказывается,  любые события в этом мире можно строго упорядочить, а именно пересчитать.  Ну что значит упорядочить? Я могу взять любое число от единицы до бесконечности и этому числу поставить в соответствие событие. Это у меня первое, это второе, ну и при этом, соответственно, я каждой циферке ставлю одно число. Ну и, соответственно, после этого я могу легко определить,

15:14
одно событие раньше другого, то есть меня даже может не волновать время, сколько важна информация, что одно событие произошло раньше, другое.  И, соответственно,  исходя из этого…

15:33
Как бы все системы и все, что у нас происходит в нашем мире, оно... То есть как бы... Сейчас еще дам поправку.  Что значит событие в общем мировом масштабе? То есть если представить, что тут наша вселенная, универсум, назовем так, и наша вселенная находилась в каком-то состоянии, в состоянии С.

16:03
Ну там пусть будет S, K.

16:07
то когда происходит вот это событие, это событие может повлиять на состояние нашей системы,  на состояние нашей системы, и наша система в этот момент времени переходит в новое качественное состояние, SKA plus 1. То же самое, пока какое-то событие в этом мире не произойдет, никаких изменений не будет с точки зрения состояния. То есть, все, что происходит,  это

16:38
событийная такая то есть такая модель нашего мира что мы все можем разложить на изменение состоянии то есть надо тут интересно интересная такая как бы интерпретация что события на самом деле если посмотреть что каждое событие помимо того что это информация что оно переводит к изменению состояния системы на новое на новый уровень то на самом деле событие

17:08
можно интерпретировать как изменение состояния. Дельта вот этого.  У нас порядок строгий, то есть может у нас быть два события в одно и то же время или нет? Не, не может. Они четко между собой разделяются? Да, они строго, то есть два события в один момент времени не могут произойти. есть всегда одно позже или раньше другого.

17:37
есть события строго упорядочены.  Соответственно,  тут есть, конечно, технические вопросы,  что это делать, но так или иначе это сводится к... Ну,  простая история. Допустим, нас два человека одновременно кликают. У нас все равно есть регистрирующее какое-то там оборудование, там, я не знаю, это световое, например. И все равно один кликнет раньше, другой. Вот.

18:06
То есть никогда мы не зафиксируем прилета этих двух фотончиков одинаково в одно время.  Соответственно,  события можно трактовать как изменения состояния системы.

18:24
То есть, грубо говоря,  та информация, насколько у нас отличается состояние системы в следующий момент времени. Простой пример. Давайте кликер рассмотрим. То есть, у нас есть время. Вот тут снизу нарисую время.  И вот, соответственно, нас, допустим, нас два игрока.  Там Петя и Вася, например. И они кликают лайки.

18:55
Петя кликает красными.

19:04
А давайте так, Петя кликает сердечки типа лайк.

19:10
А Вася кликает Dislike. То есть Петя нравится, а Вася не нравится. То есть он в другую сторону работает.

19:27
Теперь что же является состоянием? Состоянием нашей системы, например,  является суммарное количество лайков. При этом мы считаем, что один дизлайк снимает уже ранее созданный лайк. То есть нас получается система стартует с того, что лайков нет, ну ноль. Лайк появился, значит плюс один.  Дизлайк ноль, минус один,  ноль,  минус один,  ноль.

19:57
плюс один,  ноль, плюс один. Итого плюс один. То есть это вот именно значение, сумма. То есть если я беру какой-то кусочек и суммирую все свои события, которые у меня были,  это и есть состояние. То на самом деле то, что происходит у нас в базах данных, есть не что иное, как последовательная обработка событий. Ну тоже давайте пример приведу,  чтобы было... Ну, пример на уровне таблицы.

20:27
То есть, например, у нас есть таблица пользователей.

20:32
Вот, таблицы пользователей, мы их... Ну и теперь рассматриваем наше событие. Значит, первое событие. Мы добавили Вася.

20:43
в систему. Дальше соответственно мы добавили Петю.

20:49
Потом Вася нам не понравился. Мы убрали Вася. Потом нам нравится Петя.  Мы ему выставили флажок, что он красавец.  Молодец. А теперь что является состоянием? И где же тут таблица возникает?  На этом уровне нас таблица пустая. Ни ничего нет. Как только приходит Вася,  мы в таблицу вносим.

21:20
Вася. Приходит Петя. У нас табличка. И соответственно теперь две записи.  Вася.  Петя. Приходит событие о том,  что Вася надо убрать. Соответственно мы убираем Вася, остается только Петя. Ну и приходит событие, что Петя красавец. Да, мы пишем Петя. И добавляем ему флажочек. Что Петя красавец.

21:51
на петь осложить то есть любой момент времени то есть соответственно до таблички это базы данных а синенькая это потоки данных вот соответственно поток событий да упорядоченных мы называем и вон фло или стрим его называют либо фло но вообще на самом деле часто используют стрим слово поток событий и вот

22:19
Комплекс event-processing заключается в том, что мы начинаем эти потоки событий различным образом обрабатывать.  Давайте посмотрим,  что же с этими потоками событий можно делать.  Давайте двигаемся. есть потоки событий я буду рисовать такой шпажкой.

22:46
пашка да значит значит теперь значит мы будем то есть если в етл использовал слово transform

23:00
типа как преобразование, узкое очень. Мы не будем использовать слово «трансформ», мы будем использовать слово «операция» или «оператор».

23:12
Операция над потоками. есть комплекс event processing это про жонглирование потоков и соответственно оно отличается от вот это ETA или ELT, что во-первых потоков не один может быть, а много и операции могут быть гораздо более изощреннее, чем просто transform. Давайте самая простая операция,  которая у нас может быть.

23:41
Ну, пример временной операции – это задержка. Делай. То есть я могу перенумеровать эти события.  Допустим, первое, так давайте,  ну давайте так, первое, второе, третье, четвертое. После преобразования я получу те же самые четыре штучки, но смещенные по времени. Первое, второе, третье, четвертое.  Это операция.

24:10
временная, на уровне преобразования потоков событий. То есть я взял этот поток событий и, соответственно, применил некоторое волшебное преобразование, которое называется delay.  Вот, соответственно, то есть если этот поток назвать там, я не знаю,  s... s0,  то вот этот поток — это delay от s0. Ну так, это грубо для записи. Токсично немножко. Цвет получился. Вот.

24:39
Что можно еще сделать потоками из такого как бы интересного? Ну потоки можно соответственно фильтровать. То есть у меня есть поток данных. Ну и допустим у меня там разные события.  Есть красенькие,  есть зелененькие.

25:04
И я хочу из этого потока эти события извлечь. Ну не то что я хочу, я могу по каким-то нужным построить новый поток событий,  оставив только зелененький.

25:20
Тут зелененькая, тут зелененькая, тут зелененькая. То есть это оператор фильтрации или выборки, то есть его можно назвать Select,  его можно назвать Wear, его можно назвать Filter. Суть одинаковой. есть опять же, есть некий поток s0.  Применяем оператор, получаем вот такую вещь.  Соответственно,  это операция над одним потоком, но...

25:48
Оказывается, потоки можно и комбинировать.  Самый простой, рассмотрим вариант. Такой мы пока без деталей. У меня был поток данных. Тут у меня были красенькие события по времени.

26:04
Тут у меня были зелененькие события. Давайте я вам сейчас конкретный приведу. У меня есть, например,  счета, которые я выставил, а это платежи, которые я получил.  Значит, платежки, которые я получил от бухгалтерии, что мы получили. То тут мы счета выставили, а тут платежки. Вот у меня теперь строго упорядоченный поток.

26:33
который собран из двух как бы линий событий таких,  на котором теперь эти события перемешались, но внутри они строго упорядочены. То есть они в каком-то порядке идут. Ну и соответственно, где тут time consistency,  что тут возникает. То есть если мне надо где-то,  иметь в табличку, что вот я выставил, то есть у меня есть какой-то там...

27:01
предложение, коммерческое предложение,  счет и факт оплаты, то, соответственно, я могу получать эти события, вносить сюда данные и рано или поздно, если мы говорим,  что придет событие либо то, что счет оплачен, либо то, что там договор отменен, рано или поздно я получу, соответственно, либо галочку, либо крестик. Другое дело, что нарушается в каждый момент времени и в результате того, что эти потоки могут...

27:29
Данные могут поступать с разной задержкой, я могу получить вначале сведения о том, что счет оплачен, а потом получить только детали о счете. Но рано или поздно, если мне предоставляются некоторые гарантии,  если события я точно получу, то я точно приду в согласованное состояние. Вопрос только времени.  Теперь более детально.  С чем это связано?

28:00
что это позволяет делать,  и соответственно некоторые модели ближе к практике и к реализации. И вообще модель описания такой системы. То что это даёт? Это даёт следующее, что поскольку мы теперь ушли как бы на атомы, на такой молекулярный уровень, то есть мы ушли с понятия данных на табличек.

28:28
а на порции изменений. Это позволяет теперь выстраивать более сложные схемы и отдавать данные быстрее. Раньше,  при этом, соответственно, проводя всякие манипуляции. Например, у нас есть источник данных.  Ну, давайте аукционы расскажу.  У нас есть заявки на выход на то, что в ближайшее... У нас есть порция событий,

28:58
о том, что в ближайшее время будет выход, в котором реклама не продана. есть это слово заявки мы убираем. убираем событие, событие, терраизвещение.

29:14
о скором выходе.

29:19
не проданной рекламы.

29:27
Вот они, вот эти вот события идут. Что происходит? Эта штука попадает в специальный блок,  который общаясь с базой данных,  этот поток дополняет и формирует такое понятие, лод. То он формирует тоже событие, но...

29:56
событиями которого являются лоты на аукцион. есть он собирает товар, лот для торгов. То есть это событие о том, что лот для торгов собран. У него есть там минимальная ставка, у него есть список участников, кто допускается до торгов.

30:22
У него есть информация о самом товаре, то есть там широта, долгота, где этот экран находится, там какая-то аудитория и прочие сведения. То есть это событие о том, что лот собран и что хотелось бы,  что его можно продать.  Вот. Что у нас есть такой товар. После этого...

30:50
Значит, это попадает в другую систему, она на самом деле там, ну, это неважно, попадает в другую систему, которая называется проведение торгов.  Проведение торгов. Система, да, система, которая занимается проведением торгов, она пожирает лоты и выплевывает другие события.  Значит,  это событие о том,

31:20
то для того чтобы провести аукцион необходимо собрать ставку.

31:32
собрать ставку с определенного игрока.  Но это не сообщение, это надо интерпретировать как событие о нехватке ставки от определенного игрока. То есть у нас, например,  есть участники в торгах, там Вася, Петя, Дима. Вот тут я нарисую Вася. Ну, там пусть будет Вася и Петя.  Ну, соответственно, мы формируем о том, что

32:02
по такому-то товару нам не хватает ставки от Васи,  а по другому не хватает ставки от Пети. Но в рамках конкретного торгов, есть торги можно как-то пронумеровать, лоты 1, 2, 3.  И у нас, соответственно, для

32:31
первого соответственно лота да не хватает ставку от вася не хватает ставки от пети по второму лоту не хватает ставки от вати от пети ну соответственно дальше есть блок которые или блоки да которые это дело потребляют я так нарисую что тут может разделяться процесс да блоки уже опрашивают значит непосредственно ващу петь удатость вася уходит там красный

33:00
заявки про Вася, которые к Вася относятся. А к Пети заявки связаны с Петей.  Ну и соответственно после этого идет поток в обратную сторону. То есть мы собираем ставки и соответственно у нас в обратную сторону идет поток собранных

33:29
Ну что значит собранных цен? Что Вася сделал ставку, Вася сделал ставку там один доллар,  Петя сделал ставку там 50 центов и так далее. Соответственно это уходит в обратную сторону.  Вот этот блок соответственно там что-то проводит, аккумулирует.

33:51
И соответственно после этого он формирует победителя и идет поток в обратную сторону. Все это потоки событий. есть в обратную сторону какой поток идет? Что аукцион какой-то состоялся или не состоялся?  Например,  не состоялся. Состоялся и с объявлением победителя. Вася

34:19
4 доллара, что он выиграл ставку. После чего, соответственно, это попадает сюда,  и соответственно происходит отдача в обратную сторону. Это я один из кусочков сделал. В чем же тут плюсы от баз данных?  Первое,  для того чтобы данные зарегистрировать, поскольку они упорядочены, можно использовать системы хранения.

34:49
данными гораздо более дешевую. есть сама работа с данными более быстрая.  Это первое. Второе. Мы всегда можем расширять логику.  есть события, как я уже сказал, они уже когда-то произошли и они не меняются, это означает, что я могу наращивать потребителей. То есть я могу вот этот поток собрать,  отщепить его и начать там, я не знаю.

35:16
считать так такую вещь как типа кэшло то есть считать сумму минимальных ставок например да минимальных минимальных ставок и понять теперь что вот тут вот у меня проходит там я не знаю там один кик и килодоллар там в секунду например вот а это соответственно это минимальные ставки да а тут соответственно это уже например разыгранные ставки да то есть это что мы совершили сделку насколько

35:44
сделок мы совершили мы совершили сделок там на 10 тысяч килодолларов в секунду например поток вот а потом реклама выходит и у нас происходит подтверждение выхода рекламы да а после подтверждения у нас опять усыхает поток до там например там 8 килодолларов вот соответственно система становится потоковой то есть это напоминает как течение воды по руслу

36:12
Вот, ну и это позволяет... Почему, значит, это относится к рангу систем с низкой задержкой? Потому что я, если я понимаю, что я пользователю должен предоставить какие-то данные раньше, я могу,  зная специфику своей задачи, начать отгружать эти данные быстрее, да, не дожидаясь всей большой обработки. А по ходу, то есть он будет получать данные, то есть каждый, то есть при такой системе я могу обеспечить...

36:41
добычу или передачу данных максимально быстрым способом. Но опять же жертва этих систем это значит

36:54
консистентность, правило. есть мы от нее отказались и теперь, соответственно,  данные теперь размазаны в этих событиях, которые мы можем получать какой-то задержкой. Теперь плавно переходим к модели и после этого как раз можно будет перейти к вам к заданию на поиграться. Теперь к модели.  Как такие системы строить?

37:24
описывать и проектировать.  И самое важное,  не надо думать, что это не относится к некоторым языкам программирования или не относится к областям. Например, frontend, мобильная разработка или создание консольных приложений.

37:53
Этот подход применим абсолютно ко всем везде. В общем, где вы можете программировать,  применим данный подход.  Начиная от ввода в консоль,  заканчивая соответственно какими-то большими распределенными системами. То есть это может быть как внутри программы, между программами, внутри базы данных это может быть.

38:23
и так далее.  Модель. Как такие системы? Точнее, как вот у любой предметной области есть модель, и у этой системы, и проективной системы тоже есть модель.  Она идет со времен теории массового обслуживания.  Один из таких людей, который приложил основную руку, это Эрланг.

38:48
Вот модель приблизительно следующий. Для моделирования таких событийных модель выглядит следующим образом. Водится понятие очередь, очередь, очередь событий.

39:10
Водится понятие канал обработки.

39:16
Тут каналы обработки.

39:23
каналы обработки.

39:27
обработки и соответственно в результате обработки у нас получается тут я уже так аккуратно напишу

39:41
Ну давайте я на самом деле... Давайте так пока так. Вот это основная модель.  Основные ее части. Это очередь и каналы обработки.  Что такое очередь? Почему я написал тут even queue? Что на самом деле очередь это способ фиксации или описание наших событий. То есть наши события, же упорядочены.

40:10
Вот, и мы говорим, что это способ...

40:16
хранение и фиксации событий. То очередь определяет, каким образом мы храним эти события.  мы же моделируем нашу эволюционирующую по времени динамическую систему. То есть что это такое? Она получает в каждый период времени новую порцию данных,  и кто-то соответственно с этим делает, подправляет свое состояние. То есть она не может

40:46
потреблять там в другом порядке чем они произошли вот соответственно даже наверное тут немножко многовато сделал давайте чуть-чуть сейчас это подрежу канал обработки пока уберу

41:12
обработки это так давайте так мы не будем пока про тмо это перебор нам это не нужно модель следующая давайте так я это все уберу все не нужно модель следующий мы ее поменяем этот а то получается мы уже слишком перешли нас всем реализацию значит модель следующие что нам нужна собственно говоря вот это вот

41:43
Очередь событий.  Queue. Event Queue. есть мы события фиксируем как раз по очередности. Это такое наше фиксирующее оборудование.  Что произошло событие, мы его зафиксировали. Вот E1.  такс. И я уберу тут направление. То есть это теперь очередность фиксирования событий. есть нас событие пришло.

42:11
Первое появилось где-то, мы его зафиксировали. есть очередь – это, считайте, фиксирующее оборудование. То есть мы записали первое событие, пришло второе событие, мы второе записали, третье, третье записали, четвертое, четвертое, ну и там пятое. Теперь, если мы хотим смоделировать систему, в которой различные люди, там Вася, Петя, получают вот эти события, информацию.

42:40
Вася, Петя.  тоже чтобы шапочки оденем.

42:50
зелененькая шапочка вот две шапочки если мы хотим смоделировать такую систему чтобы каждый из них обработал события и там принял что делать такая дискретная система нам идет происходят события и каждый обрабатывает значит что мы должны сделать мы должны это событие из фиксирующего оборудования извлечь вот например вот это я 1 и передать на обработку обоим

43:19
То есть первый получает первое событие, второй получает событие. После этого они обрабатывают его,  и событие извлекается. есть если такая синхронная система,  моделирует дискретный наш мир. То есть мы переходим всегда от события к событию,  и отдавая всем потребителям, чтобы они скорректировали, что они там думают. Соответственно, Вася Петя.

43:48
могут предпринять какие-то действия,  операции,  которые приведут рано или поздно каким-то новым событием, которые попадут опять вот сюда. Это такая вот дискретная модель. То есть, если у нас есть много игроков, акторы. Вот, например, я хочу смоделировать на компьютере комнату, в которой общаются пять человек. Когда человек говорит какое-то сообщение, hello, я его помещаю в очередь. Кто-то говорит в ответ ему hi.

44:18
Соответственно, я тоже помещаю в очередь. А это как слух. То есть, что он услышал.  услышит. есть, этот сказал «хай», мы обработали все предыдущее, и до него дойдет событие «хай». Таким образом,  можем моделировать общение и вот эти событийные системы просто банально через очередь событий. есть, все игроки получают по событию, когда они предпринимают какие-то шаги.

44:48
Это является поводом сформировать новое событие, что любая операция или намерение совершить операцию,  это тоже событие. Таким образом,  системы моделируются.  Но именно уже для реализации событийных систем на практике уже можно перейти к более детальной модели.

45:16
модели вот этой вот теории массового обслуживания,  которая чуть-чуть расширяет, но она уже имеет более практическое назначение. есть для того, чтобы смоделировать событийные системы, эта модель не нужна. Вот, эта модель не нужна, а на самом деле мы не будем к ней переходить.  нам этого, то, что я рассказал, будет достаточно. Давайте рассмотрим интересный пример, как нам смоделировать

45:46
значит распределение работы.  вот давайте следующую схему рассмотрим. У нас есть поток работы. Ну например там кирпичи надо там таскать или там еще что-то класть.  Такая прям конкретная физическая работа. И у нас есть три рабочих. Вот сейчас как примерчик переложим.  Это работа, которую надо выполнить.

46:14
Так давайте мы уберем. То есть мы сейчас рассматриваем, что наши события они записаны в некой летописи, в каком порядке они произошли. То есть нам надо сделать работу 1, работу 2,  работу 3,  работу 4,  работу 5. И у нас есть два человека, два рабочих. Рабочий 1, рабочий 2.

46:44
Вот как на событийных системах моделировать то, что называется балансировка.  Причем оставаясь только в разряде событийных систем. Следующим образом,  давайте сделаем так. Рабочий, когда освобождается, когда рабочий свободен, он говорит, я свободен. То есть мы говорим, вот тут у нас есть такая очередь, которая фиксирует события от рабочих.

47:14
что он свободен. Ну и все начинается с того, что рабочий первый свободен и рабочий второй свободен. Вот дальше, соответственно, это поток событий. То есть вот они все начинается с того, что первый и второй рабочий говорит, я свободен. А отсюда у нас валит какая-то работа. То есть там нас есть какой-то оператор, менеджер, который сидит там за компьютером, значит,  и соответственно набивает заказы.

47:43
и формирует, что надо там экстренно делать.  А все начинается с того, что рабочие говорят,  я первый рабочий свободен, и второй говорит, и я свободен. Дальше мы говорим, что вот эти вот события, потоки,  можем скомбинировать. Как мы будем их комбинировать? Есть такая интересная операция, называется zip. Вот zip, что она делает? Она эти потоки объединяет вот так вот.

48:12
То есть это такая операция,  которая, соответственно,  просматривает поток событий. Вот этот синий и зеленый. И формирует новые события, как только она получила недостающую пару. То есть на выходе у этого оператора, который называется ZIP, я так нарисую, ZIP по-английски «молния».

48:40
Мы получаем следующую работу P1, объединенная с заявкой,  я первый освободился. То есть она их просто один к одному соединяет.  Если соответственно, дальше соответственно P2 соединяет со второй. И вот туда дальше валит. То есть если вдруг, то есть тут много накопилось,

49:09
ЗИП внутри себя может накапливать вот эту вот очередность, и как только появляется первая заявка освободившаяся, она берет событие, которое ближайшее и объединяет с этой заявкой. Тут у нас получается поток событий объединенных пар. То есть работа P1 с информацией о том, что рабочий первый освободился.

49:39
И следующая, да, это P2 информация о том, что рабочий 2 освободился. После этого мы делаем, применяем, да, такую операцию фильтрацию.  То есть, все, что имеет P1, все, что имеет как бы единичку внизу, уходит... сейчас... Все, что имеет единичку, уходит к первому рабочему. То есть, к нему будет переходить вот этот вот P1.

50:07
то что отобрано, а то что имеет двоечку будет уходить ко второму рабочему, P2. Дальше они совершают работу и у них есть поток совершенной работы,  то есть это будет работа и какой-то результат выполнения этой работы. Ну, то есть событие, второй, второй и соответственно это то, что называется выходящий поток.

50:35
Ну, назовем это ResultStream.  Вот, то есть как балансировка работает.  У нас есть поток входящей работы. У нас есть поток заявок о том, что я освободился.  И есть некий механизм, который объединяет эти два потока.  Объединяет очень просто.

51:05
Он берет одно значение отсюда, соединяется одним значением отсюда. И это формирует новое исходящее событие. Если ему не хватает данных, он просто ждет. Ждет и запоминает. То есть он запоминает все, что пришло в первом потоке. И как только появляется пара, неважно со стороны зеленых или со стороны синих, то есть может быть такая история,  что этот сказал, что я освободился, а тут нету работы. Тогда zip, он внутри хранит что-то типа как два массива.

51:34
И как только в каждом есть по одной данных, он их объединяет и отдает на выход.  После чего, соответственно, потоки разделяются,  и работа первая идет на первую, работа идет на второй. Такая система гарантирует, что никогда ваши рабочие не будут перегружены. В любой момент времени больше двух работать не будет. При этом вы можете полностью контролировать.

52:04
Значит ваш поток данных,  то есть вам может снаружи прилетать хоть там 100 миллионов заявок. Заявок внутри системы, ее производительность зафиксирована объемом вот этих заявок. есть вот эти заявки на самом деле, что я освободился, они, можно так сказать, циркулируют по кругу. То первая, вторая.

52:30
циркулирует то есть одна и та же заявка то есть вот это вот событие о том что я освободился да попадает зип попадает к первому он начинает работать после чего он опять говорит я освободился и она грубо говоря вот количество вот этих зеленых заявок она одна и та же то есть это как будто бы такая тележка которая ездит с местом под работу да а зип это та штука которая в эту тележку

52:59
закладывает, соответственно,  работу.  Рабочий, соответственно, синий вытаскивает, тележку обратно подкидывает. есть,  как это реализуется?  Это описание событийной системы, которая описывает процесс балансировки. есть, оказывается,  событийные системы хорошо покрывают задачи балансировки и позволяют проектировать системы заранее заданной производительностью. В данном случае два рабочиха.

53:29
Эта система никогда не будет перегружена. Единственное, что нее может произойти,  очередь будет такая большая, что мы никогда не справимся.  Теперь я вам предлагаю, чтобы мы уже в следующий раз детально погрузились в эту тематику,  предлагаю вот такую систему на любом языке, на котором вы хотите, моделировать.

53:58
любыми доступными для вас средствами. сейчас расскажу, как это на пальцах моделируется. Значит, очередь событий на работу. Заводится очередь.

54:11
очередь и вы ну например вы делаете там по таймеру да ну там например каждый 5 секунд или давайте так случайно от одного там до 5 секунд вы закидываете в эту очередь ставите в очередь нq ставите новую работу пусть это будут числа рандомный 1 17 23 ну и так далее это работа вот дальше

54:41
вы заводите еще одну очередь. Еще одну очередь.  Это очередь заявок, что я свободен.  Я сва-во-ден. В этой очереди всегда в любой момент времени больше двух событий не бывает.  Здесь хранятся номер рабочего, который освободился. Первый и второй. И все начинается, когда система стартует. Старт происходит.

55:12
Вы запускаете вот этот таймер и в эту очередь помещаете две заявки.

55:21
То есть,  первый и второй свободен. Дальше, что вы делаете? Дальше вы делаете вот этот вот процесс обработчик,  который называется zip.  Его задача очень простая. Он может последовательно попытаться прочитать данные из этой очереди и из этой очереди читает.

55:50
внутри себя он хранит два списка.

55:58
Первый список, который соответствует вот этой работе.  Например,  он прочитал 1, 17, 1, 17 и так далее. А второй соответствует заявкам, этим зеленым.  Что там, первый освободился и второй. Теперь что этот зип делает? Как только у него...

56:27
Получается,  что в обоих массивах писках есть хотя бы по одному данному, он их объединяет, извлекая из массива и помещая в третью очередь. Третью очередь. Вот такая.  есть Zip вычитывает и посылает оттуда вот такую вещь, что работа номер там один.

56:56
номер рабочего,  например,  на первого. Помещает это в третью очередь.  Дальше, соответственно, значит, что вы делаете? Дальше вы делаете следующим образом.  Вот ваши рабочие. Пусть рабочие это два процесса. Каждому рабочему вы заводите по очереди. Очередь на работу для первого и для второго.

57:24
И вот тут вы добавляете метод фильтрации, фильтр. Фильтр что делает? Он вычитывает последовательно данные из этой очереди и в зависимости от вот этой нижней цифрки он помещает данные либо в эту очередь, либо в эту, либо в первую, либо вторую. Соответственно дальше ваших два обработчика есть. Вот они читают

57:54
Из этой очереди работу делают ее выполняя какую-то работу полезную, в конце что-нибудь выписывают или спят 5 секунд, имитируя работу. И после того, как они работу сделали,  они снова помещают в эту очередь события, что я свободен.

58:23
Теперь самое интересное. Казалось бы, тут много работы. Как будто бы. Но как будто бы и нет. То есть если посмотреть, как эта штука устроена, то она базируется из нескольких вещей.  Первая. Она базируется на очередях.

58:46
Одна очередь, вторая очередь.

58:52
третья очередь,  четвертая очередь,  пятая очередь, пять очередей. А вторую, она явно бьется на участке. То есть у нас есть участок ZIP, он что делает?  Первый участок у нас вот такой.

59:12
Zip читает данные с очередей,  в очередь выплевывает. Это первый участок.

59:22
Второй участок,  да, фильтр. Он получает данные отсюда и закидывает в две вот эти очереди.  Второй участок. Третий участок, это обработчик, он получает данные отсюда, проводит работу, закидывает сюда.  И вот эта штука, тоже самое. Да, получает очередь, обрабатывает,  закидывает сюда. То есть раз, два.

59:52
три, четыре участка.  Вот,  четыре участка.  И выясняется, что эти участки устроены одинаково. То есть, у них есть входящие потоки, их называют upstream.

01:00:14
Апстрим.  И нисходящий поток. Даунстрим.

01:00:22
какая-то обработка то есть каждый из этих участков устроен одинаковым образом то есть структурно да то есть у него есть один или несколько ап стримов а как правило один или несколько даун стримов и он выполняет последовательно обработку из одной или нескольких очередей последовательно вот соответственно причем тут как раз вайп кодинг и как такие системы

01:00:51
программировать.  собственно говоря, тема. Причем тут здесь в обходе. Оказывается, что использует вот эту схему, она, оказывается, состоит из одинаковых кубиков, которые работают по одинаковым принципам. То законы у них немножко разные, а принципы одинаковые. То есть тут, на самом деле, как я уже сказал,  тут раз участок, два участок, три участка, четыре участка. При этом, поскольку они используют

01:01:21
качестве входных и входящих и исходящих данных одну и же вещь как очередь то оказывается их можно значит программировать реализовывать отдельно друг от друга а в конце просто собрать как велосипед из деталей то есть давайте мы разобьем да то есть первая штука у нас что делает у нее есть очередь

01:01:50
исходных заявок и очередь, да, я свободен, там зелененький мы используем, я свободен. Дальше, соответственно, она выполняет вот вот операцию zip, это вот наша первая штука, и у нее есть исходящая очередь,  то есть это, грубо говоря, очередь назначенных рабочих на задачу, то есть тут у нас, значит, работа, работа.

01:02:19
А тут свободный рабочий. Она отдает назначение рабочего на работу. Вот это первый участок. Второй участок. Он уже фильтрующий фильтр.

01:02:37
Фильтр. Он что делает? Он получает назначенную работу.

01:02:45
Вот и отдаёт это в очереди на двух рабочих.  То есть это работа к выполнению.  Работа выполнению первого.  Работа к выполнению второго.  И дальше, соответственно,  собственно говоря,  блок посвящён рабочему. То есть у первого рабочего у него есть очередь его работы. То есть работа...

01:03:15
У него два потока.

01:03:21
и соответственно я свободен.

01:03:26
очередь ну и у второго рабочего все тоже самое вы один и две очереди вот то есть теперь переходя к вайп ходим куда практически в большинстве языков но если мы возьмем front-end там это type script там c sharp ну понятно для бэкэнда вот значит для обоих

01:03:54
этих языков есть понятие интерфейса.  Вот, соответственно, что мы можем сделать?  То есть мы можем описать вначале, то есть первое, описать саму задачу, нашу, попросить систему, чтобы она сделала ее потоковой.  То есть мы открываем chatbot, говорим, дружище, я хочу приминговую систему, я хочу использовать C sharp, я хочу иметь следующую вещь. У меня там

01:04:22
3 или 4 одинаковых блока, мы можем эти блоки просто словами описать. Мы можем описать upstream.  То есть мы говорим, что у upstream у блока это поток работы и поток заявок о том, что я свободен. Он их комбинирует по схеме zip,  как можно писать zip, и результат помещает в другую работу,  в другую систему.

01:04:52
Вот такие блоки, самом деле,  вы можете попросить подготовить интерфейсы. Интерфейс как такая штука запускается. есть очевидно, надо как-то проинцелизировать, передать соответственно. На самом деле, потоковой системы очень просто. У них очень простой интерфейс из разряда run-async. Мы запускаем процесс обработки. Должны передать вот эти две очереди.

01:05:21
они у нас чем-то должны описаны быть.  Там результирующую очередь,  и какие-то настройки у ZIP и все. И он возвращает промисс или task и работает.  То есть что вы делаете? То первое, вы учитесь в терминах событийных систем правильно описывать свою задачу. То есть первое, вы должны уметь ее... Ну, вы сейчас поиграетесь на...

01:05:47
вот этой задачей она уже такая advanced на самом деле балансировка не примитивная она собственно говоря показывает все прелести системы то есть вы берете чат бота и говорите у меня есть четыре участка у меня событийная потоковая система значит первый участок занимается назначением на работу у него есть очередь работ работы это upstream и есть очередь заявок что событие о том что рабочий освободился zip комбинирует их

01:06:15
перекладывает это в назначенных рабочих. У меня есть фильтр,  диспетчер,  который получает события о назначенных работах и каждому из рабочих передает в очередь на рабочего. У меня есть сам рабочий, который работает крайне примитивно. Он берет из очереди на работу элемент и соответственно обрабатывает его и перекладывает его.

01:06:44
значит,  в очередь, то есть результат перекладывает в очередь результатов и передает заявку, что я свободен. есть каждый блок вы так описываете,  вы пытаетесь соответственно попросить через вот этот run async через интерфейс, просите,  ну в C-sharp вы можете использовать в качестве очередей класс Channel из коробки.

01:07:13
С фронтендом чуть посложнее,  но вы можете либо попробовать бота, чтобы он вам предложил, что там с очередями есть. Второй вариант, можете взять Design.js, там есть тот же самый портированный вариант Channel со всеми те же самыми атрибутами, и там есть текстовое описание полностью, как эта штука работает.

01:07:37
как она значит... Очередь тоже самая. У нее две операции, там записать, прочитать, больше ничего нету. Ну или вы можете попросить бота реализовать простейшую очередь. Ну там, я не знаю, например, просто по времени, там, чтение или синхронную очередь. То есть вы можете через опрос сделать, там, каждые 5 секунд спрашивать, есть ли там значение в очереди, а очередь простейший массив. Вот, ну я к чему,  что значит, эти зипы, фильтр и рабочих вы можете...

01:08:06
даже попросить бота реализовать самым тупым способом самое важное что вы должны просить бота то ваша система должна быть что она составная то есть это участки ваши вот эти производственные что у вас 4 участка ну или там три участка 3 типа участка вы хотите чтобы эти участки были реализованы отдельно вначале вы просите давай дружище договоримся какие очереди мы будем использовать и давай мы выделим интерфейсы по участкам он выдастся

01:08:36
описание этих интерфейсов дальше вы попросите соответственно сделать реализацию каждого из участков имплементацию на основе описания что он делает zip фильтр и рабочих вот дальше соответственно вы попросите использовать реализации интерфейсы составить этот составить композицию типа дружище вот у меня есть вот

01:09:06
4 реализации, будь любезен, соедини их вместе, чтобы они работали.  И, как до этого было указано, важно,  чтобы ваша программа началась с того, что все должно… Ну, самый простой вариант, что рабочие, как только они там стартуют, вот эти,  они первым делом формируют заявку, что я свободен. Остановку мы пока не рассматриваем. Это уже сложная тема для следующего вещи.

01:09:34
Вот основное, что отсюда надо вытащить.  Первое, что большинство систем,  даже такие, как всякие распределения задач,  укладывают в событийные вещи. Это такая уже система, где заявки циркулируют по кругу. Вот они называются замкнутые.  Второе,  что этот подход позволяет выстраивать сложнейшие системы, дробя её на...

01:10:02
вот эти вот как бы участки производственные, которые имеют очень простой вид. Что-то взять,  помутузить, куда-то отдать. Взять можно с одного места, можно с нескольких. И куда-то переложить. есть получается, что мы переходим в некоторую сторону лего.  То есть имея вот производственные участки, и зная, что они берут, мы можем комбинировать их, создавая большие сложнейшие системы.

01:10:31
То есть это первое. Второе, то программировать такие системы можно легко по частям. То есть по каждому участку.  Третье,  то есть вы можете спокойненько разработать отдельный участок вот этот вот с zip, например. Третье, я хочу чтобы вы применили TDD в качестве домашней работы.  Вы в чат бота просите, вы описываете этот участок.

01:11:00
Пишите, какие у него исходящие потоки, какие не исходящие. Можете описать требования на описание вот этих вот событий. Что работа передается числом.  Что событие о том, что рабочий освободился, тоже передается числом, что у два рабочих. А он передает событие о том, что рабочий назначен, что это пара.

01:11:29
То есть описание работы, например, строка или число, и номер рабочего, который свободен. То есть это как бы первое.  Первое – это сгенерировать интерфейс и реализацию.  Ну и подготовить описание.  Второе... Я уже запутался. Второе, третье.  Следующая вещь я хочу, чтобы вы под это дело подготовили тесты. То есть вы берете чат-боты и говорите.  Дружище!

01:11:58
У меня есть вот такая фигня. У нее есть метода рата runAsync. Ей надо передать две входящие очереди, одну выходящую очередь. Эта штука делает тот, а тот, а тот. Ну или chatbot может это вставить в комментарии интерфейса. И дальше вы просите, дружище, будь любезен,  используй TDD, XUnit.  Или если это frontend, вы говорите TDD используя джест.  Будь любезен.

01:12:28
наделай мне тесты используя там три ключевых слова там given,  then,  которые покрывают там edge-кейсы.  Сделай мне там 10-20 тестов. Сгенерируй мне, пожалуйста. То есть вы получаете интерфейс.

01:12:53
описание работы то смотреть порядок такой первое вы описываете вообще ваш участок что это за фигня для чего она нужна и какие данные там словами нужно хранить второе вы просите дружище давай-ка сделаем чтобы упакуем это в интерфейс через запуск чтобы через вот эту функцию чтобы интерфейс отражал вот эти вот вещи что оно там получает

01:13:19
данные в таком-то виде выдают. То в раносинке мы должны будем передать вот эти вот очереди. На чтение одна на записи. Второе, как только вас будет интерфейс, вы переходите к TDD, говорите, так, дружище, давай тесты проведем.  Мы туда записываем, сюда записали. То есть сделай тесты, 20 или 10 тестов, на всякие хитрые комбинации. Вы получите тесты, которые будут тестировать интерфейс. Это очень важно.

01:13:50
То есть вы просите, что тесты они под интерфейс делаются.  А дальше, соответственно, вы уже просите его сделать реализацию.  И, соответственно,  используя уже заданный тест под интерфейс, пробуйте применить их для своей конкретной реализации.  То есть тесты, которые тестирует интерфейс, они спокойно могут...

01:14:16
любой экземпляр протестировать. есть вы получите реализацию этого участка, этого,  этого и этого. И все будут покрыты тестами. Поскольку здесь нет ни одной временной составляющей, а это потоковая система, то есть выходящие данные зависят только от входящих, то она прекрасно тестируется. Она прекрасно тестируется.  Вот. Ну и последний этап. Когда вы получите 4 реализации, вы просите бота,  ну можете скинуть ему весь к**й.

01:14:44
Код, который получен до этого. Говорите, дружище,  комбинируй теперь мне в одну большую систему, и он соответственно вам соберет. То есть вы попрожляетесь это, посмотрите время,  чего сколько на это уйдет. Ну и мы тогда встречаемся с вами допустим послезавтра в понедельник. Ну и посмотрим результаты, то есть у кого чего ушло. Вот основное, что надо понять, что

01:15:12
Разбивая систему на такие простые участки,  мы достигаем именно вот этой вот композиции или декомпозиции. Мы можем теперь её дробить по частям, начинать стыковать.  Имея эти операции, мы можем тащить наши данные до баз данных.  Это уже в будущих встречах я вам расскажу, как происходит стыковка с баз данных,  есть с событий на системе хранения.

01:15:39
И как и система хранения, опять извлекается обратно в событийные потоки, потоки данных и тащится это до нужного потребителя,  сквозь всякие хитрые преграды. Ну и про кэша мы поговорим, но это уже потом. Все, то есть вы сейчас берете вот этот комплекс, например,  который показывает балансировку через систему событий распределения.  И пробуйте на там frontend, на back-end за моделить его.  На C-sharp в качестве очередей вы используете ченнелы.

01:16:09
для фронт-энда,  либо какую-то реализацию сейчас будут попросить сделать там, нулевую, которая подойдет под очередь, либо, соответственно, берете с дизайн.js ченел, он есть портированный, там есть две операции, read-assink, write-assink и try-read, try-write,  которые позволяют закинуть и выкинуть.  Вот, все, то есть наша задача научиться описывать эти участки.

01:16:38
комбинировать их. есть смотрите, чат-бот вам не сможет построить большую потоковую систему, но он сможет легко вам вот эти вот участки быстро их набивать. То вы должны научиться просто взять ручку в руки,  нарисовать потоки событий, вот эти обработчики, операции,  какие бывают и какие техники бывают по работе,

01:17:04
с этими потоками мы рассмотрим дальше.  очень большая тема, может быть даже вообще не на один раз. То есть там есть групповые, порядковые операции,  группирующие, ранжирующие операции,  временные операции. То есть там очень много на самом деле классных схем, которые позволяют чудовищные вещи делать. Ну например, в данном случае мы могли бы не одну заявку пускать, а две. Что я свободен, я свободен. Это приведет к тому, что

01:17:33
очередь на рабочего всегда будет может оказаться до двух задач вот таким образом мы минимизируем издержки на вот это вот на комбинацию да то есть тут можно еще повыше произойдет просто увеличивая количество ну там буферизацию да но правда это будет ценой там простое вот ну и так далее то есть тут можно всякие вещи там хитрые но и про очереди про

01:18:00
характеристики как это как события технически накладываются на очереди что на самом деле события иногда можно делать вытесняющим это мы тоже посмотрим но то опять же от предметной области она все давайте уже так дофиги счем времени вот

